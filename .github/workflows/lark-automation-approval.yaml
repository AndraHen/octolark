name: Automate Release Notes and Lark Approval

on:
  workflow_call:
    inputs:
      LARK_FORM_CODE:
        description: 'Lark approval code'
        required: false
        type: string
        default: 605D2BD4-4628-484A-8273-EA7862BED19B
      RELEASE_TYPE:
        description: 'Release type'
        required: false
        type: string
        default: 'Service Release'
      TEAM:
        description: 'Github team'
        required: true
        type: string
      REGION:
        description: 'Region where the bucket is located'
        default: 'ap-southeast-3'
        type: string
      SERVICE_NAME:
        description: 'The name of the service to be released'
        required: true
        type: string


jobs:
  release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Get IAM Role with OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-duration-seconds: 3600
          role-to-assume: arn:aws:iam::317144351506:role/octolark-oidc-role
          role-session-name: gh-actions-lark-approval
          aws-region: ${{ inputs.REGION }}

      - name: Generate changelog
        id: changelog
        env:
          GITHUB_TOKEN: ${{ secrets.ORG_GODWITBOT_TOKEN }}
        run: |
          # Get current release tag from branch name (e.g. release/20250623-3 -> 20250623-3)
          release_branch=${GITHUB_REF#refs/heads/}
          new_release_tag=${release_branch#release/}
          
          # Obtain ECS cluster and service information
          service_name=${{ inputs.SERVICE_NAME }}
          echo "Service name: $service_name"
          
          cluster_arn=$(aws ecs --region ap-southeast-3 list-clusters --no-paginate --query "clusterArns[?contains(@, \`${service_name}\`) == \`true\`] | [0]" --output text)
          if [[ "$cluster_arn" == "None" ]]; then
            echo -e "\033[0;31mNo cluster found for service: ${service_name}\033[0m"
            exit 1
          fi
          echo "ECS cluster: $cluster_arn"
          
          service_arn=$(aws ecs --region ap-southeast-3 list-services --cluster "$cluster_arn" --no-paginate --query "serviceArns[0]" --output text)
          if [[ "$service_arn" == "None" ]]; then
            echo -e "\033[0;31mNo service found in cluster: $cluster_arn\033[0m"
            exit 1
          fi
          echo "ECS service: $service_arn"

          task_definition_arn=$(aws ecs --region ap-southeast-3 describe-services --cluster "$cluster_arn" --service "$service_arn" --query 'services[0].taskDefinition' --output text)
          if [[ "$task_definition_arn" == "None" ]]; then
            echo -e "\033[0;31mNo task definition found for service: $service_arn\033[0m"
            exit 1
          fi
          echo "Current active task definition: $task_definition_arn"
          
          # Extract the commit ID used in production from the task definition
          image=$(aws ecs --region ap-southeast-3 describe-task-definition --task-definition "$task_definition_arn" --query 'taskDefinition.containerDefinitions[?name!=`datadog`] | [0].image' --output text)
          echo "Current active image: $image"
          
          image_tag=$(echo "$image" | awk -F: '{print $2}')
          echo "Current active image tag: $image_tag"
          
          # Currently known image tag pattern: [<env>-]<commit_id>-<repo_name>_<build_number>
          # Example: abcdef-mfc-papi_123456
          # Example rollback tag: production-abcdef-mfc-papi_123456
          commit_id=$(echo "$image_tag" | sed -E 's/^([a-z]*-)?([a-f0-9]+)-(.*(_[0-9]+)?)$/\2/')
          if [[ "$commit_id" == "$image_tag" ]]; then
            echo -e "\033[0;31mImage tag '$image_tag' does not follow known pattern, cannot extract commit ID\033[0m"
            exit 1
          fi
          echo "Current production commit ID: $commit_id"
          
          latest_release_tag="$commit_id"

          repo="${GITHUB_REPOSITORY}"
          commits_json=$(git log "$latest_release_tag"..HEAD --pretty=format:'%H|%ae|%s' | jq -R 'split("|") | {message:(.[2]|gsub("\""; "\u0027")), email:.[1], hash:.[0]}' | jq -s .)
          log="### What's Changed"$'\n\n'
          complete_commits_json="[]"
          while read -r row; do
            message=$(echo "$row" | jq -r '.message')
            email=$(echo "$row" | jq -r '.email')
            hash=$(echo "$row" | jq -r '.hash')
          
            login=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
                 "https://api.github.com/repos/$repo/commits/$hash" | \
                 jq -r '.author.login')
          
            # Fallback if login not found
            if [ -z "$login" ]; then
              login="$email"
            fi
          
            complete_row=$(echo "$row" | jq --arg username "$login" '.username = $username')
            complete_commits_json=$(jq -c --argjson row "$complete_row" '. += [$row]' <<< "$complete_commits_json")
            log+=$'* '"$message by @$login"$'\n'
          done < <(echo "$commits_json" | jq -c '.[]')

          compare_url="https://github.com/${repo}/compare/${latest_release_tag}...${new_release_tag}"
          log="${log}"$'\n\n'"**Full Changelog**: ${compare_url}"

          if gh release view "$new_release_tag" > /dev/null 2>&1; then
            echo "Delete release notes $new_release_tag because it already exists..."
            gh release delete "$new_release_tag" -y
          fi
          
          if git tag | grep -q "^$new_release_tag"; then
            echo "Delete remote tag $new_release_tag because it already exists..."
            git tag -d $new_release_tag
            git push origin ":refs/tags/$new_release_tag"
          fi

          echo "Creating new release $new_release_tag with start-tag $latest_release_tag for target branch $release_branch..."
          gh release create "$new_release_tag" --title "$new_release_tag" --notes-start-tag "$latest_release_tag" --notes "$log" --target "$release_branch"
          encoded=$(echo "$complete_commits_json" | base64 | tr -d '\n')
          echo "commits_json=$encoded" >> $GITHUB_OUTPUT

      - name: Create Lark Approval
        run: |
          commits_json=$(echo ${{ steps.changelog.outputs.commits_json }} | base64 --decode)
          workflow_url=$(echo "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}")
          author_username=$(echo "$commits_json" | jq '[.[] | .username] | unique')
          release_notes=$(echo $commits_json | jq -c 'map({
            "Feature Description": .message,
            "Author": [ .username ],
            "PIC": [ .username ],
            "Testing Approach": "Engineer Self Testing",
            "Testing Remarks": "TODO"
          })')

          lambda_payload=$(cat <<EOF
          {
            "approval_code": "${{inputs.LARK_FORM_CODE}}",
            "initiator_author": "${{github.actor}}",
            "pattern_key_authors": ["Release Notes.[].Author.[]", "Release Notes.[].PIC.[]"],
            "comment_in_case_missing_author": "Please add non-registered authors on Lark below",
            "form_value": {
              "Release Notes": $release_notes,
              "Release Type": "${{inputs.RELEASE_TYPE}}",
              "Impacted System": "${{inputs.TEAM}}",
              "Github Workflow": "$workflow_url",
              "Impacted Service": "${GITHUB_REPOSITORY}",
              "Monitoring Plan": "",
              "Release Prerequisites": "",
              "Rollback Method": ""
            }
          }
          EOF)

          aws lambda invoke \
            --function-name lark-approval-creation \
            --payload "$lambda_payload" \
            --cli-binary-format raw-in-base64-out \
            response.json

          echo "Lambda response:"
          cat response.json | jq